#Започваме с йерархични структури от данни
йей.


Но преди това, ще е хубаво да сме се занимавали достатъчно със списъци :)

**Задача 1.** Дефинирайте процедура, която ъъ flat-ва списък - тоест
прави максималната му дълбочина 1. Всъщност ето някакви примери, днес говоренето
на майчин език хич не ми се получава. Ако ми хрумне нещо по-хубаво, ще редактирам.

```Scheme
(flatten '(1 3 ("wow" ("nesting") ("overload" 38 91)))) -> '(1 3 "wow" "nesting" "overload 38 91)
(flatten '(1 2 3)) -> '(1 2 3)
(flatten '(((3)))) -> '(3)
```

**Задача 2.** Дефинирайте процедура, която проверява дали **поне един** елемент от даден списък
изпълнява някакво условие.

```Scheme
(any? odd? '(4 6 8 13 16)) -> #t
(any? string? '(12 #f (lambda (x) (* x x)))) -> #f
```

**Задача 3.** Дефинирайте процедура, която проверява дали **всички** елементи от даден
списък изпълняват някакво условие.

```Scheme
(all? even? '(12 16 18 40 166662)) -> #t
(all? (lambda (x) (= (length x) 3)) '((1 2 3) (3 4 5) (3 2))) -> #f
```

**Задача 4.** Даден е списък от цели числа. Всички негови елементи, без един, са или само
четни или само нечетни. Дефинирайте процедура, която връща елементът, който не е със същата четност като останалите.

```Scheme
(remove-odd '(1 3 17 25 4 13 55)) -> 4
(remove-odd '(-5 20 12 88 92)) -> -5
```

**Задача 5.** Дефинирайте процедура, която връща първите n елемента на даден списък.
```Scheme
(take 3 '("irrelevant" "words" "whatever" "i'm sleepy")) -> '("irrelevant" "words" "whatever")
(take 2 '(9 12 293 23)) -> '(9 12)
```

**Задача 6.** Дефинирайте процедурата **take-while**, подобна на **take**, но с разликата, че
спираме да добавяме в новия списък, когато дадено условие не е изпълнено.

```Scheme
(take-while even? '(2 4 18 40 21 30 22)) -> '(2 4 18 40)
(take-while (lambda (x) (= (string-length x) 3)) '("okg" "sdp" "fp")) -> '("okg" "sdp")
```

**Задачи 7 - 11 (here comes the fun part)** Дефинирайте процедури за работа с двоично дърво.

Като начален тласък ще се яви процедурата, която създава такова дърво, а именно:
```Scheme
(define (make-tree root left right)
    (list root left right))
```

Това ще рече, че за нас двоичните дървета ще означават списък от 3 неща:
+ корен на дървото
+ ляво поддърво (списък)
+ дясно поддърво (списък)

Идеята е същата като тази с рационалните числа - правим някаква абстракция
с вградени в езика структури (при рационалните числа беше pair, тук използваме list).

**Задача 7.** Дефинирайте процедури, които за дадено двоично дърво връщат:
+ Неговия корен (root tree)
+ Лявото му поддърво (left tree)
+ Дясното му поддърво (right tree)

**Задача 8.** Дефинирайте процедура, която проверява дали дадено двоично дърво е празно. (empty?)

**Задача 9.** Дефинирайте процедура, която проверява дали **x** е елемент на дадено двоично дърво.
(member-tree? tree x)

**Задача 10.** Дефинирайте процедура, която проверява дали дадено дърво е листо.
(leaf? tree)

**Задача 11.** Дефинирайте процедура, която проверява дали **х** е листо в дадено двоично дърво.
(member-leaf? tree x)