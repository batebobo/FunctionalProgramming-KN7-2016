#Ако

първото нещо, което се питате всяка сутрин е: "Брей, как ли пък
се работи със списъци в Scheme?", или "Как въобще е реализирана
структурата списък в този, на пръв поглед, прост език?", значи следващите
няколко реда ще са ви от полза.

##Предисловие

Езикът Scheme, както може би знаете, е диалект на един друг (по-стар) език,
носещ името LISP. Името на LISP, пък, произхожда от LISt Processor".
Следователно, на структурата от данни **списък** ще се обърне (пре)достатъчно
внимание в рамките на този курс. Преди да навлезем в света на списъците, ще
е хубаво да започнем с по-проста структура от данни, а именно pair (двойка).

##Чифт, двойка и pair

са взаимнозаменяеми имена на нещото, което в рамките на този файл ще наричаме pair.
В езика са вградени няколко основни процедури за работа с pairs:

####Конструктор
```Scheme
; (cons a b) - прави pair, чийто първи елемент е a, а втори - b
(cons 6 1) -> (6 . 1)
(cons (+ 1 3) (* 2 4)) -> (4 . 8)
```

####Селектори
```Scheme
; (car pair) - връща първия елемент на даден pair.
; името на процедурата е архаизъм и означава "Contents of the Address part of Register"

(define my-pair (cons 6 10))
(car my-pair) -> 6
(car (cons 11 22)) -> 11
```

```Scheme
; (cdr pair) - връща втория елемент на даден pair.
; името на процедурата е архаизъм и означава "Contents of the Decrement part of Register"
(define my-pair (cons 7 12))
(cdr my-pair) -> 12
(cdr (cons 11 22)) -> 22
```

Може да правите двойки от абсолютно всичко, което ви хрумне - било то
числа, процедури (и lambda изрази), други двойки и прочие.

```Scheme
(define plus-minus (cons + -))
((car plus-minus) 3 4) -> 7
((cdr plus-minus) 6 2) -> 4

(define nested-pair (cons
                       (cons 2 4)
                       6))
(car nested-pair) -> (2 . 4)
(cdr nested-pair) -> 6
```

##А сега -
плъхове. В значителна част от публикуваната литература за Scheme (поне тази част, 
която съм имал шанс да видя с очите си), като пример за използването на pairs
се използват рационалните числа. И най-често процедурите, които се създават за работа с
рационални числа имат двусмислени имена.

Нека рационално число за нас да означава двойка, чийто първи елемент да наречем
числител, а втория - знаменател. Процедурата "създай плъх" ще се погрижи за създаването на
рационални числа.
```Scheme
; Конструктор
(define (make-rat numer denom)
    (cons numer denom))
```
И нека имаме следните селектори за числител и знаменател:

```Scheme
; Числител - numerator
(define (get-num rat)
    (car rat))
```

```Scheme
; Знаменател - denominator
(define (get-denom rat)
    (cdr rat))
```

Оставям на Вас да напишете процедурите "събери плъхове, умножи плъхове, извади плъхове и раздели плъхове".
След като вече може да намирате най-големият общ делител на две числа, ще се справите и с 
процедурата "опрости плъх". Ето примерни сигнатури на фунцкиите:

```Scheme
(sum-rat rat1 rat2)
(mul-rat rat1 rat2)
(sub-rat rat1 rat2)
(div-rat rat1 rat2)
(simplify-rat rat)
```

##Време е за списъци

Подходящо ще е да мислите за списъците в този език като много двойки,
навързани една за друга. Както (може би) сте виждали по СДП,
съществува структура от данни "свързан списък". Тя представлява много
кутийки с по два елемента - първият е този с данните, а вторият е указател към следваща
кутийка. Тук ще мислим по подобен начин, само че ще работим с вече познатата ни
структура pair.  
Нека имаме списъкът от числа  
(1 2 3 4 5).  
Ще си мислим, че той представлява следното:  
(1, (2, (3, (4, (5, '())))))  
Първият елемент на всяка двойка съдържа данните (в случая числата, от които
се състои списъкът ни), а вторият - следващата *кутия*.
Празната *кутия* (списък) обозначаваме с '().

###Конструиране
В Scheme има няколко начина да създадем списък.  
Нека отново използваме (1 2 3 4 5).  

```Scheme
; Вариант 1 - много вложени двойки
(cons 1 (cons 2 (cons 3 (cons 4 (cons 5 '()))))) -> (1 2 3 4 5)
; Вариант 2 - синтактично улеснение на Вариант 1
(list 1 2 3 4 5) -> (1 2 3 4 5)
; Вариант 3 - цитиране
'(1 2 3 4 5) -> (1 2 3 4 5)
```
Нека разгледаме вариант 2 и 3.
```Scheme
(define a 5)
(define b 10)

(list a b) -> (5 10)
'(a b) -> (a b)
```

Вариант 2 ще оцени всички изрази, подадени като аргументи на list, докато вариант 3
използва т.нар. цитиране. Понякога ще се налага да правим списъци от символи, за които
е необходимо цитиране с цел избяване на оценяването.  
Следната аналогия би помогнала за различаването на двете опции:
```
- Кажи ми името си!
- Петър.

- Кажи ми "името си"!
- Името си.
```

След като видяхме начините да конструираме списък, нека разгледаме селекторите, с които ще работим:

```Scheme
; Селектор, който връща първия елемент на даден списък
(car list)
(car (list 1 2 3)) -> 1
```

```Scheme
; Селектор, който връща всички елементи след първия на даден списък
(cdr list)
(cdr (list 1 2 3)) -> (2 3)
```

**Полезно** е да мислите за car и cdr като за **head** и **tail** на списък.
Свикнете с имената на вградените процедури (car, cdr), но при желание ги преименувайте на
нещо, което е по-разбираемо за вас. Например:
```Scheme
; това е възможно ако head и tail нямат никакво значение в средата, в която работите
(define head car)
(define tail cdr)
```

Нека имаме следните вложени списъци:

list := (1 2 (3 4 5) (6 (7 8)))

**Задача 1** Вземете 2 с подходящи извиквания на car и cdr.
**Задача 2** Вземете 4 с подходящи извиквания на car и cdr.
**Задача 3** Вземете всички останали елементи един по един с подходящи
извиквания на car и cdr.

**Решение на Зад.1** (car (cdr list))
**Решение на Зад.2** (car (cdr (car (cdr (cdr list)))))

**За мен** е удобно да чета извикванията на фунцкиите отвътре-навън (Inside out е
много готин филм на Disney & Pixar от миналата година. Пуснете си го, за да се успокоите
след това чудо със списъците).  
**Тоест** (car (cdr (car (cdr (cdr list))))) като list := (1 2 (3 4 5) (6 (7 8)))
Се превежда до следното:
1. cdr - Вземи всички елементи на списъка без първия - ще получим (2 (3 4 5) (6 (7 8)))
2. cdr - Вземи всички елементи на списъка без първия - ще получим ((3 4 5) (6 (7 8)))
3. car - Вземи първия елемент на спиъска - ще получим списъкът (3 4 5)
4. cdr - Вземи всички елементи без първия - ще получим (4 5)
5. car - Вземи първия елемент на списъка - ще получим 4

Сега влагате фунцкиите в ред от 5. към 1. и получавате желания резултат.

Има няколко ситактични "улеснения", които евентуално биха ви спестили
влагане на car и cdr до полудяване.  
```
(cadr list) е еквивалентно на (car (cdr list))
(caadr list) е еквивалентно на (car (car (cdr list)))
```

Възможни са всякакви комбинации на c(a,d)r като броят на символите между c и r не може
да превишава 4.

**Предикат, проверяващ дали списък е празен:**
```Scheme
;(null? list)
(null? '()) -> #t
(null? (list 1 2 3)) -> #f
```

**Задача 1.** Дефинирайте процедура, която връща дължината на даден списък.
**Задача 2.** Дефинирайте процедура, която проверява дали елемент х се съдържа в даден списък.  
**Задача 3.** Дефинирайте процедура, която приема списък с числа и го превръща в число по следния начин:
```Scheme
(list-to-num (list 3 4 5 6)) -> 3456
(list-to-num (list 1 2)) -> 12
```







