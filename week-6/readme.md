#Какво разгледахме на упражнението

##Работа с двоични дървета
като продължение на задачите, които ви бях оставил за вкъщи. Силно се надявам
повечето неща да са станали ясни. Не исках да губим много време за тази
структура, тъй като тя играе чисто илюстративна роля (каквато беше и тази
на рационалните числа отпреди няколко седмици).
```
Показахме как можем да "обвием" списък в Scheme, да го кръстим "двоично
дърво" и да си създадем удобен интерфейс за работа с него.
```

Интерфейсът ни включва:
+ Конструктор (make-tree root left right)
+ Селектор за корен (root tree)
+ Селектор за ляво поддърво (left tree)
+ Селектор за дясно поддърво (right tree)
+ Проверка дали едно дърво е празно (empty? tree)

С него успяхме да реализираме функциите за:

1. проверка дали едно дърво е листо
```Scheme
(define (is-leaf? tree)
    (and (empty? (left tree))
         (empty? (right tree))))
```

2. проверка дали **х** се среща в дадено дърво
```Scheme
(define (member? x tree)
    (if (empty? tree)
        #f
        (if (= (root tree) x)
            #t
            (or (member? x (left tree))
                (member? x (right tree))))))))
```

3. проверка дали **х** е листо в дадено дърво
```
Practice
```

4. провека дали в дадено дърво съществува път от а до b (props to Георги)
```Scheme
(define (path-from-to first second tree)
    (if (empty? tree)
        #f
        (if (= (root tree) first)
            (member? second tree)
            (or (path-from-to first second (left tree))
                (path-from-to first second (right tree)))
```

##Работа с матрици,
които представяме като списък от редове, а всеки ред е списък с елементи.
Например:
```Scheme
(define my-matrix '((1 2 3) (4 5 6) (7 8 9)))
; Или малко по-красиво подреждане
(define pretty-matrix '((12 3 25)
                        (3 5 10)
                        (15 7 29)))
```

За да работим по-удобно с такъв вид структура, дефинирахме функцията
**list-ref**, която ни връща n-тия елемент на даден списък:

```Scheme
(define (list-ref xs n)
    (cond ((> n (- (length xs) 1)) (display "Index out of range"))
          ((= n 0) (car xs))
          (else (list-ref (cdr xs) (- n 1)))))
```

За да вземем n-тия ред на дадена матрица, може да дефинираме следната функция:
```Scheme
(define get-nth-row list-ref)
```
![Magic](http://gifyu.com/images/magicb41e5.gif)

Да вземем n-тата колона е малко по-tricky.

```Scheme
;Вариант 1
(define (get-nth-col matrix n)
    (if (null? matrix)
        '()
        (cons (list-ref (car matrix) n)
              (get-nth-col (cdr matrix) n))))
              
;Вариант 2
(define (get-nth-col matrix n)
    (map (lambda (row) (list-ref row n)) matrix))
```
Силно подкрепям избягването на решения тип "Вариант 1" :)
Вариант 2 прави следното:  
Трансформирай така matrix, че от всеки негов елемент (сиреч - ред на матрицата - списък)
да вземеш n-тия му член с list-ref.  
Ако например извикаме (get-nth-col '((1 2 3) (4 5 6) (7 8 9)) 2),
map ще вземе първия елемент на матрицата (1 2 3) и ще върне 3. След това
ще вземе (4 5 6) и ще вземе 6. И последно за (7 8 9) взима 9.  
Така от списъкът '((1 2 3) (4 5 6) (7 8 9)) получихме чрез адекватна трансформация с map
списъкът (3 6 9).

Да вземем на диагонал на матрица е още по-tricky.  
Идеята е да имаме индекс (със звучното име **i**), който се мени
от 0 до броя на редовете. С помощта на този индекс, можем на всяка стъпка да взимаме
i-тата колона на i-тия ред.

```Scheme
(define (primary-diagonal matrix)
    (define (diagonal-helper matrix i)
        (if (= i (length matrix))
            '()
            (cons (list-ref (get-nth-row matrix i) i)
                  (diagonal-helper matrix (+ i 1)))))
    (diagonal-helper matrix 0))
```

Решение на същата задача може да се състави и без използване на индекс.
На първа стъпка взимаме най-горния ляв елемент на матрицата (с индекс 0 0).
След това извикваме функцията ни рекурсивно като махаме първия ред и първата колона на матрицата.
По този начин с всяко извикване ние "смаляваме" матрицата докато не постигнем желания резултат.

```Scheme
Practice
```
