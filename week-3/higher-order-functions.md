#Функции от по-висок ред, accumulate и прочие

Както си говорихме преди известно време, в езика Scheme може да
дефинирате функции (наричат се **функции от по-висок ред, или
higher-order functions**), които приемат други функции като аргументи
(или връщат функция като резултат).

**Например:**  
```Scheme
(define (apply-twice operation x)
    (operation (operation x)))
    
(define (+2 x) (+ x 2))
(define (square x) (* x x))

(apply-twice +2 3) -> 7
(apply-twice square 3) -> 81
```

Тук apply-twice приема функция (operation) за аргумент, следователно е
функция от по-висок ред.

##Важна забележка:
```Scheme
(apply-twice 1 2) -> Грешка - опитвате се да приложите процедурата "1",
която не съществува
(apply-twice square "string") -> Грешка - не може да умножавате символни низове.
```
Вие се грижите да извиквате функциите си с правилен тип (и брой!) аргументи.
Преди да извикате функция, много добре проверявайте какви (и колко!) аргументи
се очаква да ѝ се дадат.

##lambda изразите
са функции, които не се свързват с имена. Наричат се още "анонимни функции".
Имат следните **важни** предназначения:
Могат да бъдат връщани като стойност;
Могат да бъдат подавани като параметри на функция.

Всичко, което може да постигнете с обикновена дефиниция на функция, може да
постигнете и с lambda - двете форми са напълно взаимнозаменяеми.

*В Scheme, define е синтактично улеснение на езика, зад което се крие 
lambda т.е. когато интерпретаторът стигне до define израз, веднага го
преобразува в lambda израз.*

###Синтаксис
```Scheme
(lambda (<args>) <body>)
```
Където args са аргументите на функцията, а body - нейното тяло.

Ето например как можем да дефинираме lambda израз и да го извикаме веднага:

```Scheme
((lambda (x) (+ x 20)) 12) -> 32
```
Тук функцията ни приема един параметър и го увеличава с 20. След 
нейната дефиниция, веднага я прилагаме към 12 и съответно получаваме резултат.
Добре е да се отбележи, че функцията, която дефинирахме тук, не е достъпна
никъде другаде в кода - никой друг не може да я извика (тя няма име).

Ето пример за lambda израз с повече от един аргумент:

```Scheme
((lambda (x y z)
    (cond ((and (> x y) (> x z)) x)
          ((> y z) y)
          (else z))) 1 2 3) -> 3
```

##Връщане на функции като резултат
Ето че стигнахме и до втория тип функции от по-висок ред - сега ще връщаме
функции.

```Scheme
(define (parse operation)
    (cond ((string=? operation "+") +)
          ((string=? operation "-") -)
          ((string=? operation "*") *)
          ((string=? operation "/") /)))
          
((parse "*") 3 4) -> 12
```
Такава дефиниция може да срещнем в програма, занимаваща се с обработка на
input и/или пресмятане на математически изрази. В зависимост от това какъв символ
срещнем, връщаме съответната операция.

Нека дефинираме **композиция (h) на функции (f, g)** - h(x) = f(g(x)).
```Scheme
(define (compose f g)
    (lambda (x) (f (g x))))
```

По този начин ние връщаме lambda израз (който си е функция) с един аргумент.

```Scheme
(define (add1 x) (+ x 1))
(define (square x) (* x x))
(define add1-then-square (compose square add1))

(add1-then-square 3) -> 16
```

Нека видим какво се случва тук стъпка по стъпка:  
Дефинираме си функциите, чиято композиция искаме да получим.  
(Същият ефект бихме постигнали и с ламбда - примерът долу илюстрира точно това)  
Дефинираме add1-then-square като композиция на две функции.
По нашата дефиниция за compose, сега add1-then-square е
едноаргументна функция.
Извикваме add1-then-square и получаваме резултат.

##More - TBA