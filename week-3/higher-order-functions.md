#Функции от по-висок ред, accumulate и прочие

Както си говорихме преди известно време, в езика Scheme може да
дефинирате функции (наричат се **функции от по-висок ред, или
higher-order functions**), които приемат други функции като аргументи
(или връщат функция като резултат).

**Например:**  
```Scheme
(define (apply-twice operation x)
    (operation (operation x)))
    
(define (+2 x) (+ x 2))
(define (square x) (* x x))

(apply-twice +2 3) -> 7
(apply-twice square 3) -> 81
```

Тук apply-twice приема функция (operation) за аргумент, следователно е
функция от по-висок ред.

##Важна забележка:
```Scheme
(apply-twice 1 2) -> Грешка - опитвате се да приложите процедурата "1",
която не съществува
(apply-twice square "string") -> Грешка - не може да умножавате символни низове.
```
Вие се грижите да извиквате функциите си с правилен тип (и брой!) аргументи.
Преди да извикате функция, много добре проверявайте какви (и колко!) аргументи
се очаква да ѝ се дадат.

##lambda изразите
са функции, които не се свързват с имена. Наричат се още "анонимни функции".
Имат следните **важни** предназначения:
Могат да бъдат връщани като стойност;
Могат да бъдат подавани като параметри на функция.

Всичко, което може да постигнете с обикновена дефиниция на функция, може да
постигнете и с lambda - двете форми са напълно взаимнозаменяеми.

*В Scheme, define е синтактично улеснение на езика, зад което се крие 
lambda т.е. когато интерпретаторът стигне до define израз, веднага го
преобразува в lambda израз.*

###Синтаксис
```Scheme
(lambda (<args>) <body>)
```
Където args са аргументите на функцията, а body - нейното тяло.

Ето например как можем да дефинираме lambda израз и да го извикаме веднага:

```Scheme
((lambda (x) (+ x 20)) 12) -> 32
```
Тук функцията ни приема един параметър и го увеличава с 20. След 
нейната дефиниция, веднага я прилагаме към 12 и съответно получаваме резултат.
Добре е да се отбележи, че функцията, която дефинирахме тук, не е достъпна
никъде другаде в кода - никой друг не може да я извика (тя няма име).

Ето пример за lambda израз с повече от един аргумент:

```Scheme
((lambda (x y z)
    (cond ((and (> x y) (> x z)) x)
          ((> y z) y)
          (else z))) 1 2 3) -> 3
```

##Връщане на функции като резултат
Ето че стигнахме и до втория тип функции от по-висок ред - сега ще връщаме
функции.

```Scheme
(define (parse operation)
    (cond ((string=? operation "+") +)
          ((string=? operation "-") -)
          ((string=? operation "*") *)
          ((string=? operation "/") /)))
          
((parse "*") 3 4) -> 12
```
Такава дефиниция може да срещнем в програма, занимаваща се с обработка на
input и/или пресмятане на математически изрази. В зависимост от това какъв символ
срещнем, връщаме съответната операция.

Нека дефинираме **композиция (h) на функции (f, g)** - h(x) = f(g(x)).
```Scheme
(define (compose f g)
    (lambda (x) (f (g x))))
```

По този начин ние връщаме lambda израз (който си е функция) с един аргумент.

```Scheme
(define (add1 x) (+ x 1))
(define (square x) (* x x))
(define add1-then-square (compose square add1))

(add1-then-square 3) -> 16
```

Нека видим какво се случва тук стъпка по стъпка:  
Дефинираме си функциите, чиято композиция искаме да получим.  
(Същият ефект бихме постигнали и с ламбда - примерът долу илюстрира точно това)  
Дефинираме add1-then-square като композиция на две функции.
По нашата дефиниция за compose, сега add1-then-square е
едноаргументна функция.
Извикваме add1-then-square и получаваме резултат.

Подобен пример:

```Scheme
(define (repeat f n)
    (if (= n 1)
        f
        (compose f (repeat f (- n 1)))))
        
(define add3 (repeat (lambda (x) (+ x 1)) 3))

(add3 2) -> 5
```

Тук дефинираме "повторение" на функция n пъти, или
```
(repeat f 3) -> h(x) = (f (f (f x)))
```

##Още един пример за функции от по-висок ред
са комбинаторите.  

**Задача 1** Да се дефинира процедура, която намира сумата на числата в интервала [a,b]
```Scheme
(define (interval-sum a b)
    (if (> a b)
        0
        (+ a (interval-sum (+ a 1) b))))
```

**Задача 2** Да се дефинира процедура, която намира сумата на четните числа в интервала [a,b]
```Scheme
(define (even-sum a b)
    (define (sum a b)
        (if (> a b)
            1
            (+ a (sum (+ a 2) b))))
    (if (odd? a)
        (sum (+ a 1) b)
        (sum a b)))
```
Забележете, че процедурите interval-sum (от зад.1) и product (зад.2) имат
някои сходства.  
1. И при двете минаваме през интервал [a,b]
2. Дъното на рекурсията е, когато превишим b
3. Увеличаваме a с всяка стъпка.
4. Прилагаме събиране върху елементите от интервала.

Има много примери за функции с тези общи елементи. Нека разгледаме още един.

**Задача 3** Да се дефинира процедура, която намира сумата 1 + 1/2 + 1/3 + ... + 1/k
```Scheme
(define (random-sum a b)
    (if (> a b)
        0
        (+ (/ 1 a) (random-sum (+ a 1) b))))
```
Тук имаме същите 4 общи елемента с предишните 2 функции, но наблюдаваме и нещо друго:  
Не прилагаме операцията (+) върху текущото число от интервала [a,b], а върху (/ 1 а). Тоест 
някаква функция на текущото число от интервала.

Сега можем да редактираме списъкът с общи елементи на тези процедури:

1. Минаваме през интервал [a,b]
2. Дъното на рекурсията е, когато превишим b
3. Увеличаваме a с всяка стъпка.
4. Прилагаме някаква операция върху **функция на текущия елемент от интервала.**

С тези неща на ум, може да дефинираме следната абстрактна процедура, която обхваща в себе си
всички, които написахме досега

```Scheme
(define (sum a b term next)
    (if (> a b)
        0
        (+ (term a) (sum (next a) b term next))))
```
Нека чрез новодефинираната функция "sum" да се опитаме да решим **зад.3**
```Scheme
(define (random-sum a b)
    (sum a b (lambda (x) (/ 1 x)) (lambda (x) (+ x 1))))

;Или - оригиналното ни решение

(define (random-sum a b)
    (if (> a b)
        0
        (+ (/ 1 a) (random-sum (+ a 1) b))))
```
Оригиналното решение на **Зад.3** и последното (използвайки sum) са напълно идентични.
Тук се вижда и добро използване на ламбда изрази - процедурите, които делят 1 на х и увеличават
х с 1 са тривиални и няма смисъл за тях да се пишат отделни define изрази.

###Нека дефинираме още по-асбстрактна процедура,
която ще кръстим accumulate. При нея ще параметризираме операцията и върнатата
стойност при достигане дъното на рекурсията. Нека я дефинираме така
```Scheme
(define (accumulate op term null-value a next b)
    (if (> a b)
        null-value
        (op (term a) (accumulate op term null-value (next a) next b))))
```

Така написаната функция прилича много на "sum" отпреди малко. Вместо винаги да връщаме 0
при достигане дъното на рекурсията, вече човекът, който използва функцията ни
може да си избере подходяща стойност. Същото важи и за операцията - това е пример за
абстрактна процедура (по-късно ще видим как може да я използваме за "акумулиране" на резултат
на функции).

**Задача 4** Да се реши зад. 3 с accumulate.
```Scheme
(define (random-sum a b)
    (accumulate + (lambda (x) (/ 1 x)) 0 a (lambda (x) (+ x 1)) b))
```
Нека сега проследим следното извикване:
```Scheme
(random-sum 2 6)
```
1. стигаме до (if (> 2 6)), което очевидно е лъжа.
2. прилагаме операцията + към (term 2), което в нашия случай представлява (/ 1 2) И
3. към accumulate със същата операция, същия term, същото null-value,
4. (next a), което за нас значи (+ а 1), същия next и същото b
5. при новото влизане в accumulate, имаме а = 3 и b = 6
6. стигаме до (if (> 3 6)), което очевидно е лъжа.
7. прилагаме операцията + към (term 3), което за нас е (/ 1 3). Досега във
"веригата" на пресмятания имаме (+ (/ 1 2) (/ 1 3)...)
8. отново втория аргумент на операцията (+) е рекурсивно извикване на accumulate, и отново увеличаваме а.
Няколко стъпки по-късно - а = 7, b = 6

Имамe (if (> 7 6)), което връща #t и като резултат от последното рекурсивно извикване на 
accumulate имаме null-value (което за нас е 0). Тоест получаваме следната верига:
(+ (/ 1 2) (/ 1 3) (/ 1 4) (/ 1 5) (/ 1 6) 0)  
+ е операция, която приема случаен (>= 2) брой аргументи.

